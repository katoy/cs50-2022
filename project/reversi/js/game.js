// Generated by CoffeeScript 1.12.7

/*
リバーシ。
盤面のクラスと、単純なコンピュータ思考ルーチン２つ。
 */

(function() {
  var AI_Base, AI_First, AI_Gain, AI_Montecarlo, AI_Negamax, AI_Random, Rating, Reversi,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Reversi = (function() {
    var dXY, setMessage, setStatMessage;

    Reversi.STONE_IMAGE_WIDTH = 50;

    Reversi.STONE_IMAGE_HEIGHT = 50;

    Reversi.VOID = 'images/void.jpg';

    Reversi.BLACK = 'images/black.jpg';

    Reversi.WHITE = 'images/white.jpg';

    Reversi.HINT_B = 'images/hintB.jpg';

    Reversi.HINT_W = 'images/hintW.jpg';

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    function Reversi(core, gameSize1, stoneDispWidth) {
      this.gameSize = gameSize1 != null ? gameSize1 : 8;
      this.stoneDispWidth = stoneDispWidth != null ? stoneDispWidth : 1.0;
      this.fps = core.fps;
      this.num_stone = this.gameSize * this.gameSize;
      this.scale = this.stoneDispWidth / Reversi.STONE_IMAGE_WIDTH;
      this.SPRITES = [];
      this.BoardState = [];
      this.turn = 1;
      this.start = false;
      this.BlackStone = this.WhiteStone = 0;
      this.players = [0, 0];
      this.records = [];
      this.play_pos = 0;
      this.replay_mode = false;
      core.preload([Reversi.VOID, Reversi.BLACK, Reversi.WHITE, Reversi.HINT_B, Reversi.HINT_W]);
    }

    Reversi.prototype.setCPUs = function(cpus) {
      this.cpus = cpus;
    };

    Reversi.prototype.isInBoard = function(x, y) {
      return (x >= 0) && (x < this.gameSize) && (y >= 0) && (y < this.gameSize);
    };

    Reversi.prototype.xy2pos = function(x, y) {
      return x + y * this.gameSize;
    };

    Reversi.prototype.pos2xy = function(pos) {
      return [pos % this.gameSize, Math.floor(pos / this.gameSize)];
    };

    Reversi.prototype._getSprite = function(pos) {
      var height, ref, ref1, ref2, stone, width, x, y;
      ref = [Reversi.STONE_IMAGE_WIDTH, Reversi.STONE_IMAGE_HEIGHT], width = ref[0], height = ref[1];
      stone = new Sprite(width, height);
      stone.image = new Surface(width * 5, height);
      stone.pos = pos;
      ref1 = this.pos2xy(pos), x = ref1[0], y = ref1[1];
      stone.frame = 0;
      stone.scale(this.scale, this.scale);
      ref2 = [x * width * this.scale, y * height * this.scale], stone.x = ref2[0], stone.y = ref2[1];
      stone.image.draw(enchant.Game.instance.assets[Reversi.VOID], 0, 0, width, height, 0, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.BLACK], 0, 0, width, height, width, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.WHITE], 0, 0, width, height, width * 2, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.HINT_B], 0, 0, width, height, width * 3, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.HINT_W], 0, 0, width, height, width * 4, 0, width, height);
      return stone;
    };

    Reversi.prototype.createBoard = function() {
      var j, pos, ref;
      this.SPRITES = [];
      for (pos = j = 0, ref = this.num_stone; 0 <= ref ? j < ref : j > ref; pos = 0 <= ref ? ++j : --j) {
        this.SPRITES.push(this._getSprite(pos));
      }
      this.firstScene();
      return this.SPRITES;
    };

    Reversi.prototype.firstScene = function() {
      var first, i, j, ref;
      for (i = j = 0, ref = this.num_stone; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.SPRITES[i].frame = 0;
        this.BoardState[i] = 0;
      }
      first = this.gameSize * (Math.floor(this.gameSize / 2 - 1)) + Math.floor(this.gameSize / 2 - 1);
      this.SPRITES[first].frame = this.SPRITES[first + this.gameSize + 1].frame = 2;
      this.BoardState[first] = this.BoardState[first + this.gameSize + 1] = -1;
      this.SPRITES[first + 1].frame = this.SPRITES[first + this.gameSize].frame = 1;
      this.BoardState[first + 1] = this.BoardState[first + this.gameSize] = 1;
      this.BlackStone = this.WhiteStone = 2;
      return document.myForm.black.value = document.myForm.white.value = 2;
    };

    Reversi.prototype.checkInvert = function() {
      var c, canPuts, ddx, ddy, dx, dy, i, j, k, pos, ref, ref1, ref2, ref3, ref4, ref5, turnX, x, y;
      canPuts = [];
      turnX = (-1) * this.turn;
      for (pos = j = 0, ref = this.num_stone; 0 <= ref ? j < ref : j > ref; pos = 0 <= ref ? ++j : --j) {
        if (this.BoardState[pos] === 0) {
          ref1 = this.pos2xy(pos), x = ref1[0], y = ref1[1];
          for (i = k = 0, ref2 = dXY.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
            ref3 = [dXY[i][0], dXY[i][1]], dx = ref3[0], dy = ref3[1];
            ref4 = [1, dx, dy], c = ref4[0], ddx = ref4[1], ddy = ref4[2];
            while (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
              ref5 = [c + 1, ddx + dx, ddy + dy], c = ref5[0], ddx = ref5[1], ddy = ref5[2];
            }
            if (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === this.turn) && (c > 1)) {
              this.BoardState[pos] = 2;
              this.SPRITES[pos].frame = ((this.turn > 0) ? 3 : 4);
              canPuts.push(pos);
              break;
            }
          }
        }
      }
      return canPuts;
    };

    Reversi.prototype.showStone = function(stone, opts) {
      var next_frame, ref, ref1, ref2, x, y;
      if (opts == null) {
        opts = {
          delay: 0,
          turn: this.turn
        };
      }
      ref = [null, null], x = ref[0], y = ref[1];
      if (opts.pos) {
        ref1 = this.pos2xy(opts.pos), x = ref1[0], y = ref1[1];
        ref2 = [x + 1, y + 1], x = ref2[0], y = ref2[1];
      }
      next_frame = (opts.turn === 1) ? 1 : 2;
      if ((this.players[0] > 0 && this.players[1] > 0) || (this.replay_mode === true)) {
        return stone.frame = next_frame;
      } else {
        if (stone.frame !== 0) {
          return stone.tl.delay(opts.delay * this.fps).scaleTo(0.1 * this.scale, this.scale, 0.2 * this.fps).then(function() {
            return this.frame = next_frame;
          }).scaleTo(this.scale, this.scale, this.fps * 0.2);
        } else {
          return stone.tl.delay(opts.delay * this.fps).then(function() {
            return this.frame = next_frame;
          });
        }
      }
    };

    Reversi.prototype.putStone = function(pos, opts) {
      var c, canPuts, cpuID, cpuPut, ddx, ddy, dx, dy, i, j, k, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, result, resultMessage, turnPos, turnX, x, y;
      if (opts == null) {
        opts = {
          delay: 0,
          turn: this.turn
        };
      }
      if (!this.start) {
        return setMessage("Click [start]");
      } else if ((this.replay_mode === false) && (this.BoardState[pos] !== 2)) {
        return setMessage("can not move");
      } else {
        for (i = j = 0, ref = this.num_stone; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (this.BoardState[i] === 2) {
            this.BoardState[i] = 0;
            this.SPRITES[i].frame = 0;
          }
        }
        ref1 = this.pos2xy(pos), x = ref1[0], y = ref1[1];
        setMessage("move at (" + (x + 1) + ", " + (y + 1) + ")");
        this.recordPlay([this.turn, x + 1, y + 1]);
        turnX = (-1) * this.turn;
        for (i = k = 0, ref2 = dXY.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
          ref3 = [dXY[i][0], dXY[i][1]], dx = ref3[0], dy = ref3[1];
          ref4 = [1, dx, dy], c = ref4[0], ddx = ref4[1], ddy = ref4[2];
          while (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
            ref5 = [c + 1, ddx + dx, ddy + dy], c = ref5[0], ddx = ref5[1], ddy = ref5[2];
          }
          if (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === this.turn)) {
            ref6 = [c - 1, ddx - dx, ddy - dy], c = ref6[0], ddx = ref6[1], ddy = ref6[2];
            while (c > 0) {
              this.BoardState[this.xy2pos(x + ddx, y + ddy)] = this.turn;
              if (this.turn > 0) {
                this.BlackStone++;
                this.WhiteStone--;
              } else {
                this.WhiteStone++;
                this.BlackStone--;
              }
              turnPos = this.xy2pos(x + ddx, y + ddy);
              this.showStone(this.SPRITES[turnPos], {
                delay: opts.delay + 0.3,
                turn: this.turn,
                pos: turnPos
              });
              ref7 = [c - 1, ddx - dx, ddy - dy], c = ref7[0], ddx = ref7[1], ddy = ref7[2];
            }
          }
        }
        this.BoardState[pos] = this.turn;
        if (!this.SPRITES[pos]) {
          alert(pos);
        }
        this.showStone(this.SPRITES[pos], {
          delay: opts.delay,
          turn: this.turn,
          pos: pos
        });
        if (this.turn > 0) {
          this.BlackStone++;
        } else {
          this.WhiteStone++;
        }
        document.myForm.black.value = this.BlackStone;
        document.myForm.white.value = this.WhiteStone;
        this.turn *= -1;
        canPuts = this.checkInvert();
        if (canPuts.length === 0) {
          setMessage(this.turn > 0 ? "Pass first palyer" : "Pass second player");
          this.recordPlay([this.turn, 0, 0]);
          this.turn *= -1;
          canPuts = this.checkInvert();
          if (canPuts.length === 0) {
            setStatMessage("Restart");
            result = this.gameResult();
            resultMessage = result === 0 ? "Draw" : result > 0 ? "Black win" : "White win";
            setMessage("game over (" + resultMessage + ")");
            return;
          }
        }
        if (((this.turn === 1 && this.players[0] > 0) || (this.turn === -1 && this.players[1] > 0)) && (this.replay_mode === false)) {
          cpuID = this.turn === 1 ? this.players[0] - 1 : this.players[1] - 1;
          cpuPut = this.cpus[cpuID].play(this.BoardState.slice(0), {
            turn: this.turn,
            canPuts: canPuts.slice(0)
          });
          if (cpuPut !== null) {
            this.putStone(cpuPut, {
              delay: opts.delay + 0.8,
              turn: this.turn
            });
          }
        }
        return null;
      }
    };

    Reversi.prototype.gameResult = function() {
      var j, len1, r, ref, s;
      r = 0;
      ref = this.BoardState;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        s = ref[j];
        r += s;
      }
      return r;
    };

    Reversi.prototype.recordPlay = function(pos) {
      if (!this.replay_mode) {
        if (this.play_pos !== this.records.length) {
          this.records = this.records.slice(0, this.play_pos);
        }
        this.records.push(pos);
        return this.play_pos = this.records.length;
      }
    };

    Reversi.prototype.exitReplay = function() {
      return this.replay_mode = false;
    };

    Reversi.prototype.replay = function(hands, len) {
      var i, j, pos, ref;
      this.replay_mode = true;
      this.firstScene();
      this.turn = 1;
      if (len < 0) {
        len = 0;
      }
      if (len > hands.length) {
        len = hands.length;
      }
      if (len > 0) {
        for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          pos = (hands[i][1] - 1) + (hands[i][2] - 1) * this.gameSize;
          if (pos >= 0) {
            this.turn = hands[i][0];
            this.putStone(pos);
          }
        }
      }
      if (len <= 0) {
        setMessage("init board");
      }
      this.play_pos = len;
      return this.replay_mode = false;
    };

    Reversi.prototype.historyTop = function() {
      return this.replay(this.records, 0);
    };

    Reversi.prototype.historyLast = function() {
      return this.replay(this.records, this.records.length);
    };

    Reversi.prototype.history = function(step) {
      return this.replay(this.records, this.play_pos + step);
    };

    Reversi.prototype.savePlay = function() {
      return alert(JSON.stringify({
        black: this.BlackStone,
        white: this.WhiteStone,
        play: this.records
      }));
    };

    Reversi.prototype.loadPlay = function() {
      return console.log("未実装");
    };

    Reversi.prototype.setPlayers = function() {
      return this.players = [document.myForm.first.selectedIndex, document.myForm.second.selectedIndex];
    };

    Reversi.prototype.gameStart = function() {
      var canPuts;
      if (!this.start) {
        this.setPlayers();
        this.start = true;
        this.records = [];
        this.play_pos = 0;
        setMessage("game start");
        setStatMessage("restart");
        canPuts = this.checkInvert();
        if (this.players[0] > 0 && canPuts.length > 0) {
          return this.putStone(this.cpus[this.players[0] - 1].play(this.BoardState.slice(0), {
            turn: this.turn,
            canPuts: canPuts.slice(0)
          }));
        }
      } else {
        if (confirm("Do you really want to restart?")) {
          this.firstScene();
          this.turn = 1;
          this.start = false;
          setStatMessage("start");
          return setMessage("restart");
        }
      }
    };

    setMessage = function(msg) {
      return document.myForm.myMsg.value = msg;
    };

    setStatMessage = function(msg) {
      return document.myForm.start.value = msg;
    };

    return Reversi;

  })();

  enchant();

  window.onload = function() {
    var core, game_board_width, game_size, reversi;
    game_size = 8;
    game_board_width = 320;
    core = new Core(game_board_width + 10, game_board_width + 10);
    reversi = new Reversi(core, game_size, Math.floor(game_board_width / game_size));
    this.reversi = reversi;
    reversi.setCPUs([new AI_First(), new AI_Random(), new AI_Gain(), new AI_Montecarlo(), new AI_Negamax(2), new AI_Negamax(3), new AI_Negamax(4), new AI_Negamax(5)].slice(0));
    core.onload = function() {
      var board, j, len1, results, stone;
      board = reversi.createBoard();
      results = [];
      for (j = 0, len1 = board.length; j < len1; j++) {
        stone = board[j];
        core.rootScene.addChild(stone);
        results.push(stone.addEventListener('touchend', function() {
          reversi.exitReplay();
          reversi.setPlayers();
          return reversi.putStone(this.pos);
        }));
      }
      return results;
    };
    return core.start();
  };

  AI_Base = (function() {
    var dXY;

    function AI_Base() {}

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    AI_Base.prototype.numStone = 64;

    AI_Base.prototype.gameSize = 8;

    AI_Base.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
    };

    AI_Base.prototype.xy2pos = function(x, y) {
      return x + y * this.gameSize;
    };

    AI_Base.prototype.pos2xy = function(pos) {
      return [pos % this.gameSize, Math.floor(pos / this.gameSize)];
    };

    AI_Base.prototype.isInBoard = function(x, y) {
      return (x >= 0) && (x < this.gameSize) && (y >= 0) && (y < this.gameSize);
    };

    AI_Base.prototype.putStone = function(boardState, pos, turn, doTurn) {
      var c, ddx, ddy, dx, dy, gain, i, j, ref, ref1, ref2, ref3, ref4, ref5, ref6, turnX, x, y;
      if (doTurn == null) {
        doTurn = false;
      }
      if (boardState[pos] !== 0) {
        return -1;
      }
      turnX = turn * (-1);
      gain = 0;
      ref = this.pos2xy(pos), x = ref[0], y = ref[1];
      for (i = j = 0, ref1 = dXY.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        ref2 = [dXY[i][0], dXY[i][1]], dx = ref2[0], dy = ref2[1];
        ref3 = [1, dx, dy], c = ref3[0], ddx = ref3[1], ddy = ref3[2];
        while (this.isInBoard(x + ddx, y + ddy) && (boardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
          ref4 = [c + 1, ddx + dx, ddy + dy], c = ref4[0], ddx = ref4[1], ddy = ref4[2];
        }
        if (this.isInBoard(x + ddx, y + ddy) && boardState[this.xy2pos(x + ddx, y + ddy)] === turn) {
          ref5 = [c - 1, ddx - dx, ddy - dy], c = ref5[0], ddx = ref5[1], ddy = ref5[2];
          while (c > 0) {
            if (doTurn) {
              boardState[this.xy2pos(x + ddx, y + ddy)] = turn;
            }
            ref6 = [c - 1, ddx - dx, ddy - dy], c = ref6[0], ddx = ref6[1], ddy = ref6[2];
            gain++;
          }
        }
      }
      if (doTurn) {
        boardState[pos] = turn;
      }
      return gain;
    };

    AI_Base.prototype.checkInvert = function(board, turn) {
      var c, canPuts, ddx, ddy, dx, dy, i, j, k, pos, ref, ref1, ref2, ref3, ref4, ref5, turnX, x, y;
      canPuts = [];
      turnX = (-1) * turn;
      for (pos = j = 0, ref = this.numStone; 0 <= ref ? j < ref : j > ref; pos = 0 <= ref ? ++j : --j) {
        if (board[pos] === 0) {
          ref1 = this.pos2xy(pos), x = ref1[0], y = ref1[1];
          for (i = k = 0, ref2 = dXY.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
            ref3 = [dXY[i][0], dXY[i][1]], dx = ref3[0], dy = ref3[1];
            ref4 = [1, dx, dy], c = ref4[0], ddx = ref4[1], ddy = ref4[2];
            while (this.isInBoard(x + ddx, y + ddy) && (board[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
              ref5 = [c + 1, ddx + dx, ddy + dy], c = ref5[0], ddx = ref5[1], ddy = ref5[2];
            }
            if (this.isInBoard(x + ddx, y + ddy) && (board[this.xy2pos(x + ddx, y + ddy)] === turn) && (c > 1)) {
              canPuts.push(pos);
              break;
            }
          }
        }
      }
      return canPuts;
    };

    return AI_Base;

  })();

  AI_First = (function() {
    function AI_First() {}

    AI_First.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.canPuts.length === 0) {
        return null;
      } else {
        return opts.canPuts[0];
      }
    };

    return AI_First;

  })();

  AI_Random = (function() {
    function AI_Random() {}

    AI_Random.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.canPuts.length === 0) {
        return null;
      } else {
        return opts.canPuts[Math.floor(Math.random() * opts.canPuts.length)];
      }
    };

    return AI_Random;

  })();

  AI_Gain = (function(superClass) {
    extend(AI_Gain, superClass);

    function AI_Gain() {}

    AI_Gain.prototype.play = function(boardState, opts) {
      var ans, gainMax, gains, i, j, k, len1, pos, ref, ref1, score, turn;
      if (opts == null) {
        opts = {};
      }
      turn = opts.turn;
      ans = null;
      gains = {};
      gainMax = -1;
      for (i = j = 0, ref = this.numStone; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (boardState[i] === 2) {
          boardState[i] = 0;
        }
      }
      ref1 = opts.canPuts;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        pos = ref1[k];
        score = this.putStone(boardState, pos, turn, false);
        if (gainMax < score) {
          gainMax = score;
        }
        if (gains[score]) {
          gains[score].push(pos);
        } else {
          gains[score] = [pos];
        }
      }
      console.log("#--- AI_gains ");
      console.log(gains);
      pos = gainMax <= 0 ? nyll : gains[gainMax][Math.floor(Math.random() * gains[gainMax].length)];
      console.log("#--- AI_Gain turn:" + turn + ", pos:" + pos);
      return pos;
    };

    return AI_Gain;

  })(AI_Base);

  AI_Montecarlo = (function(superClass) {
    var dXY;

    extend(AI_Montecarlo, superClass);

    function AI_Montecarlo() {
      return AI_Montecarlo.__super__.constructor.apply(this, arguments);
    }

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    AI_Montecarlo.prototype.numStone = 64;

    AI_Montecarlo.prototype.gameSize = 8;

    AI_Montecarlo.prototype.playCount = 5;

    AI_Montecarlo.prototype.play = function(boardState, opts) {
      var ans, drowCount, i, j, k, l, len1, p, pos, ref, ref1, ref2, turn, winCount, winMax, winer, wins, workBoard;
      if (opts == null) {
        opts = {};
      }
      turn = opts.turn;
      ans = null;
      wins = {};
      winMax = -1;
      for (i = j = 0, ref = this.numStone; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (boardState[i] === 2) {
          boardState[i] = 0;
        }
      }
      winMax = -1;
      wins = {};
      ref1 = opts.canPuts;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        pos = ref1[k];
        winCount = 0;
        drowCount = 0;
        for (p = l = 0, ref2 = this.playCount; 0 <= ref2 ? l < ref2 : l > ref2; p = 0 <= ref2 ? ++l : --l) {
          workBoard = boardState.slice(0);
          winer = this.playGame(workBoard, turn, pos);
          if (winer === turn) {
            winCount++;
          }
          if (winer === 0) {
            drowCount++;
          }
        }
        if (winCount === 0 && drowCount === 0) {
          winCount = -1;
        }
        if (wins[winCount]) {
          wins[winCount].push(pos);
        } else {
          wins[winCount] = [pos];
        }
        if (winMax < winCount) {
          winMax = winCount;
        }
      }
      console.log("#--- AI_Montecarlo(playCount=" + this.playCount + " turn:" + turn + ", pos:" + wins[winMax][0]);
      return wins[winMax][0];
    };

    AI_Montecarlo.prototype.playGame = function(board, turn, pos) {
      var canPuts, i, j, len1, pass, win;
      pass = 0;
      while (pass < 2) {
        if (pos >= 0) {
          this.putStone(board, pos, turn, true);
        }
        turn *= -1;
        canPuts = this.checkInvert(board, turn);
        if (canPuts.length === 0) {
          pos = null;
          pass++;
        } else {
          pos = canPuts[Math.floor(Math.random() * canPuts.length)];
          pass = 0;
        }
      }
      win = 0;
      for (j = 0, len1 = board.length; j < len1; j++) {
        i = board[j];
        win += i;
      }
      if (win === 0) {
        return 0;
      }
      if (win > 0) {
        return 1;
      } else {
        return -1;
      }
    };

    return AI_Montecarlo;

  })(AI_Base);

  Rating = (function() {
    function Rating() {}

    Rating.rate9 = [127, -32, 0, -1, -1, -1, 0, -32, 127, -32, -64, -1, -1, -1, -1, -1, -64, -32, 0, -1, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, 0, -1, 0, -32, -64, -1, -1, -1, -1, -1, -64, -32, 127, -32, 0, -1, -1, -1, 0, -32, 127];

    Rating.rate8 = [127, -32, 0, -1, -1, 0, -32, 127, -32, -64, -1, -1, -1, -1, -64, -32, 0, -1, 0, -1, -1, 0, -1, 0, -1, -1, -1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, -1, -1, -1, 0, -1, 0, -1, -1, 0, -1, 0, -32, -64, -1, -1, -1, -1, -64, -32, 127, -32, 0, -1, -1, 0, -32, 127];

    Rating.rate7 = [127, -32, 0, -1, 0, -32, 127, -32, -64, -1, -1, -1, -64, -32, 0, -1, 0, -1, 0, -1, 0, -1, -1, -1, 0, -1, -1, -1, 0, -1, 0, -1, 0, -1, 0, -32, -64, -1, -1, -1, -64, -32, 127, -32, 0, -1, 0, -32, 127];

    Rating.rate6 = [127, -32, 0, 0, -32, 127, -32, -64, -1, -1, -64, -32, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, -32, -64, -1, -1, -64, -32, 127, -32, 0, 0, -32, 127];

    Rating.rate5 = [127, -32, 0, -32, 127, -32, -64, -1, -64, -32, 0, -1, 0, -1, 0, -32, -64, -1, -64, -32, 127, -32, 0, -32, 127];

    Rating.rate4 = [127, -32, -32, 127, -32, -64, -64, -32, -32, -64, -64, -32, 127, -32, -32, 127];

    Rating.evalBoard = function(board, gameSize, mode) {
      var j, k, pos, rate, ref, ref1, score;
      rate = Rating["rate" + gameSize];
      score = 0;
      if (mode === "gain") {
        for (pos = j = 0, ref = rate.length; 0 <= ref ? j < ref : j > ref; pos = 0 <= ref ? ++j : --j) {
          score += board[pos];
        }
      } else {
        for (pos = k = 0, ref1 = rate.length; 0 <= ref1 ? k < ref1 : k > ref1; pos = 0 <= ref1 ? ++k : --k) {
          score += board[pos] * rate[pos];
        }
      }
      return score;
    };

    return Rating;

  })();

  AI_Negamax = (function(superClass) {
    extend(AI_Negamax, superClass);

    function AI_Negamax(depth1, gameSize1) {
      this.depth = depth1 != null ? depth1 : 5;
      this.gameSize = gameSize1 != null ? gameSize1 : 8;
      AI_Negamax.__super__.constructor.call(this);
    }

    AI_Negamax.prototype.play = function(boardState, opts) {
      var depth, i, j, mode, num_rest, pos, posAry, ref, ref1, turn, v;
      if (opts == null) {
        opts = {};
      }
      turn = opts.turn;
      num_rest = 0;
      for (i = j = 0, ref = this.numStone; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (boardState[i] === 2) {
          boardState[i] = 0;
        }
        if (boardState[i] === 0) {
          num_rest++;
        }
      }
      depth = this.depth;
      mode = "";
      if (num_rest <= 10) {
        mode = "gain";
        depth = num_rest;
      }
      ref1 = this.negaMax(depth, boardState, turn, mode), v = ref1[0], posAry = ref1[1];
      pos = posAry[Math.floor(Math.random() * posAry.length)];
      console.log("#--- AI_Negamax(depth=" + this.depth + " turn:" + turn + ", pos:" + pos + ", v=" + v);
      return pos;
    };

    AI_Negamax.prototype.negaMax = function(depth, board, turn, mode) {
      var bestPos, bestV, canPuts, evaled, j, len1, nextBoard, nextPos, v, workBoard;
      if (depth === 0) {
        return [Rating.evalBoard(board, this.gameSize, mode) * turn, null];
      }
      bestV = -32000;
      bestPos = {};
      workBoard = board.slice(0);
      canPuts = this.checkInvert(workBoard, turn);
      for (j = 0, len1 = canPuts.length; j < len1; j++) {
        nextPos = canPuts[j];
        nextBoard = workBoard.slice(0);
        this.putStone(nextBoard, nextPos, turn, true);
        evaled = this.negaMax(depth - 1, nextBoard, (-1) * turn, mode);
        v = (-1) * evaled[0];
        if (bestPos[v]) {
          bestPos[v].push(nextPos);
        } else {
          bestPos[v] = [nextPos];
        }
        if (bestV <= v) {
          bestV = v;
        }
      }
      return [bestV, bestPos[bestV]];
    };

    return AI_Negamax;

  })(AI_Base);

}).call(this);
